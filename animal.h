#include <math.h>
//--------------------------------------------------------------------------
void action(int n);
void Do(int n,int act,float weight);
void action_1(int n,float weight);              //Хаотичное движение
void action_2(int n,float weight);              //Целенаправленное движение
void action_3(int n,float weight);              //Действие при запасе энергии меньше предельно допустимого
void action_4(int n,float weight);              //Действие при запасе энергии больше предельно допустимого
void action_5(int n,float weight);              //Размножение деление на двое
void action_6(int n,float weight);               //Хищничиство
void action_7(int n,float weight);               //смерть

int N=10;      //количество микробов текущее
#define mN 1000    //количество микробов максимальное
const Pi=6;     //количество внутренних раздражителей
#define Pp 128          //с Рр начинаются внешние раздражители в A[Pn]
#define Pn 256           //количество записей в ДНК
#define calorie 4.1868   // 1 калория равна 4.1868 Джоулей
#define gl      14.235   //питательнось 1 миллиграмма глюкозы в Джоулях
#define gl_c    3.400   //питательность 1 миллиграмма глюкозы в калариях
#define tmr     100      //интервал срабатывания таймера
//--------------------------------------------------------------------------
class dnk{
        public:
        float A[Pn];      //пороговое значение раздражения-ДНК наследственная
        short int D[Pn];      //действие при превышении порогового значения
        short int nD[Pn];     //действие при меньшем порогового значения
        float W[Pn];          //вес(значимоть действия) в пределах от -1 до 1
        };
class coordinate{
        public:
        float x;      //текущая координата Х, мм
        float y;      //текущая координата Y, мм
        };
class anim : public dnk{
        public:
        float B[Pn];    //текущее значение раздражения
        float x;      //текущая координата Х, мм
        float y;      //текущая координата Y, мм
        float Vmax;     //максимальная скорость передвижения, мм/сек
        float Vflag;      //разрешение передвижения - от 0 до 1
        float V; //модуль вектора скорости движения, мм/сек
        float Vq; //угол вектора скорости движения
        coordinate prp;  //коорденаты места, куда направлен объект
        float t;        //не используется
        };
//--------------------------------------------------------------------------
anim X[mN];
#include "environment.h"
//------------Выполнение действий-------------------------------------------
void action(int n)
{
        X[n].B[4]+=tmr*0.001;                                   //старение
        X[n].x+=X[n].V*cos(X[n].Vq)*(tmr*0.001);
        X[n].y+=X[n].V*sin(X[n].Vq)*(tmr*0.001);
        X[n].B[0]-=3e-3*gl*X[n].V*(0.001*tmr)*X[n].B[1];  //затраты на перемещение
        X[n].B[1]-=3e-3*X[n].V*(0.001*tmr)*X[n].B[1]; //уменьшение массы вседствии сжигания энергии
        if(E.Gr[0][(int)(1.0*I/W*X[n].x)][(int)(1.0*J/H*X[n].y)]>(1e-6)*(tmr*0.001))   //условие увеличения энергии за счет гетеротрофности
                {X[n].B[0]+=1*1e-6*gl*(tmr*0.001);                 //увеличение энергии
                X[n].B[1]+=1e-6*(tmr*0.001);                       //увеличение массы (размеров)
                E.Gr[0][(int)(1.0*I/W*X[n].x)][(int)(1.0*J/H*X[n].y)]-=1e-6*(tmr*0.001);}  //уменьшение питательных в-в
}
//------------Определения рода выполняемого действия------------------------
void Do(int n,int act,float weight)
{
        switch(act){
                case 0: break; //действие_0 - ничего не выполнять
                case 1: action_1(n,weight);break;
                case 2: action_2(n,weight);break;
                case 3: action_3(n,weight);break;
                case 4: action_4(n,weight);break;
                case 5: action_5(n,weight);break;
                case 6: action_6(n,weight);break;}
}
//------------Действия над параметрами тела (Т, напряженность мышц)---------
//------------Хаотичное движение--------------------------------------------
void action_1(int n,float weight)
{
        X[n].V=X[n].Vmax*weight*X[n].Vflag;
        if(random(800)==4) X[n].Vq+=(random(9)-5)*M_PI/(random(4)+1);
}
//------------Целенаправленное движение-------------------------------------
void action_2(int n,float weight)
{
        int V=X[n].Vmax*X[n].Vflag;
        if(abs(X[n].prp.x-X[n].x)+abs(X[n].prp.y-X[n].y)<V)
                V=1; //замедление скорости при приближении к цели от 10 до 1
        X[n].V=V*weight;
        if (X[n].x!=X[n].prp.x)
                X[n].Vq=atan((1.0*X[n].prp.y-X[n].y)/(X[n].prp.x-X[n].x))+
                        M_PI*(X[n].prp.x-X[n].x<0?1:0);
                else if (X[n].y!=X[n].prp.y)  X[n].Vq=(X[n].prp.y-X[n].y>0)?M_PI/2:(-M_PI/2);
                else X[n].V=0;
}
//------------Действие при запасе энергии меньше предельно допустимого-------
void action_3(int n,float weight)
{
        if(E.Gr[0][(int)(1.0*I/W*X[n].x)][(int)(1.0*J/H*X[n].y)]>1e-3*(tmr*0.001))
                X[n].Vflag=0;    //остаемся на месте, если есть пища
                else
                {X[n].Vflag=1;
                action_1(n,weight);}
        if(X[n].B[0]<=0)  //смерть
                 action_7(n,0);
}
//------------Действие при запасе энергии больше предельно допустимого-------
void action_4(int n,float weight)
{
                X[n].Vflag=1;  //движение разрешено

}
//------------Размножение деление на двое------------------------------------
void action_5(int n,float weight)
{
        if(random(10800)!=0)  return;     //вероятность деления
        if(N>=mN){
                 ShowMessage("Предел по количеству микробов достигнут.");
                 return;}
        //Дочерние клетки схожи
        X[N]=X[n];
        //Уменьшение массы и энергии вдвое
        X[n].B[0]=X[n].B[0]/2;
        X[n].B[1]=X[n].B[1]/2;
        //параметры нового микроба
        X[N].B[0]=X[n].B[0];
        X[N].B[1]=X[n].B[1];
        X[N].Vflag=1;
        X[N].x=X[n].x;
        X[N].y=X[n].y;
        X[N].B[4]=0;
        X[N].Vq=M_PI*random(360)/180;
        //параметры старого микроба
        X[n].Vq=M_PI*random(360)/180;
        X[n].B[4]=0;
        add_shape();
        N++;
}
//------------Хищничиство-----------------------------------------------------
void action_6(int n,float weight)
{
        if(X[n].B[4]<100) return;        //не съедает при делении
        float minR=W;           //минимальное расстояние до жертвы
        float r;
        int Eat=-1;              //номер микроба за которым охотимся
        for(int i=0;i<N;i++){
                if(i!=n)
                {r=sqrt(pow(X[i].x-X[n].x,2)+pow(X[i].y-X[n].y,2));
                if(r<minR) {Eat=i;minR=r;}}}
        if(Eat!=-1 && minR<20*weight){      //где 20 -мах расстояние на котором хищник чует жертву
                X[n].prp.x=X[Eat].x;
                X[n].prp.y=X[Eat].y;
                //движение к цели
                action_2(n,0.8);}
        if(Eat!=-1 && minR<pow(X[n].B[1],0.3))        //если расстояние меньше радиуса микроба,съедает
                 action_7(Eat,0);
}
//------------Смерть----------------------------------------------------------
void action_7(int n,float weight)
{
        //жертва умирает увеличивается количества питательных в-в вокруг умершего микроба
        E.Gr[0][(int)(1.0*I/W*X[n].x)][(int)(1.0*J/H*X[n].y)]+=X[n].B[1];
        //убираем микроба из списка
        X[n]=X[N-1];
        //не прорисовываем 1 фигуру
        delete_shape();
        N--;
}
